% ORELM - Outlier Robust Extreme Learning Machine Class
%   Train and Predict a SLFN based on Outlier Robust Extreme Learning Machine
%
%   This code was implemented based on the following paper:
%
%   [1] Kai Zhang, Minxia Luo, Outlier-robust extreme learning machine for
%       regression problems, Neurocomputing, Volume 151, Part 3, 2015,
%       Pages 1519-1527, ISSN 0925-2312,
%       https://doi.org/10.1016/j.neucom.2014.09.022.
%       (http://www.sciencedirect.com/science/article/pii/S0925231214012053)
%
%   Attributes:
%       Attributes between *.* must be informed.
%       OR-ELM objects must be created using name-value pair arguments (see the Usage Example).
%
%         *numberOfInputNeurons*:   Number of neurons in the input layer
%                Accepted Values:   Any positive integer.
%
%          numberOfHiddenNeurons:   Number of neurons in the hidden layer
%                Accepted Values:   Any positive integer (defaut = 1000).
%
%        regularizationParameter:   Regularization Parameter (defaut = 1000)
%                Accepted Values:   Any positive real number.
%
%                        maxIter:   Max. number of iteration on ALM (defaut = 20)
%                Accepted Values:   Any positive integer number.
%
%             activationFunction:   Activation funcion for hidden layer
%                Accepted Values:   Function handle (see [1]) or one of these strings:
%                                       'sig':     Sigmoid (default)
%                                       'sin':     Sine
%                                       'hardlim': Hard Limit
%                                       'tribas':  Triangular basis function
%                                       'radbas':  Radial basis function
%
%                           seed:   Seed to generate the pseudo-random values.
%                                   This attribute is for reproducible research.
%                Accepted Values:   RandStream object or a integer seed for RandStream.
%
%       Attributes generated by the code:
%
%       inputWeight:             Weight matrix that connects the input
%                                layer to the hidden layer
%
%       biasOfHiddenNeurons:     Bias of hidden units
%
%       outputWeight:            Weight matrix that connects the hidden
%                                layer to the output layer
%
%   Methods:
%
%       obj = ORELM(varargin):        Creates ORELM objects. varargin should be in
%                                     pairs. Look attributes.
%
%       obj = obj.train(X,Y):         Method for training. X is the input of size N x n,
%                                     where N is (# of samples) and n is the (# of features).
%                                     Y is the output of size N x m, where m is (# of multiple outputs)
%
%       Yhat = obj.predict(X):        Predicts the output for X.
%
%   Usage Example:
%
%       load iris_dataset.mat
%       X      = irisInputs';
%       Y      = irisTargets';
%       orelm  = ORELM('numberOfInputNeurons', 4);
%       orelm  = orelm.train(X, Y);
%       Yhat   = orelm.predict(X);

%   License:
%
%   Permission to use, copy, or modify this software and its documentation
%   for educational and research purposes only and without fee is here
%   granted, provided that this copyright notice and the original authors'
%   names appear on all copies and supporting documentation. This program
%   shall not be used, rewritten, or adapted as the basis of a commercial
%   software or hardware product without first obtaining permission of the
%   authors. The authors make no representations about the suitability of
%   this software for any purpose. It is provided "as is" without express
%   or implied warranty.
%
%       Federal University of Espirito Santo (UFES), Brazil
%       Computers and Neural Systems Lab. (LabCISNE)
%       Authors:    F. K. Inaba, B. L. S. Silva, D. L. Cosmo
%       email:      labcisne@gmail.com
%       website:    github.com/labcisne/ELMToolbox
%       date:       Jan/2018

classdef ORELM < ELM
    properties
        maxIter = 20
        regularizationParameter = 1000
    end
    methods
        function self = ORELM(varargin)
            self = self@ELM(varargin{:});
        end
        
        function self = train(self, X, Y)
            auxTime = toc;
            tempH = X*self.inputWeight + repmat(self.biasOfHiddenNeurons,size(X,1),1);
            H = self.activationFunction(tempH);
            clear tempH;
            
            %--------------------------------------------------------------
            % ALM Algorithm for finding beta
            %--------------------------------------------------------------
            ny = size(Y,2);
            [m,n]  = size(H) ;
            kappa  = 1/self.regularizationParameter;
            nIter  = 0 ;
            mu     = 2*m/norm(Y,1);
            lambda = zeros(m,ny);
            e      = zeros(m,ny);
            converged_main = 0;
            muInv  = 1/mu ;
            if n<m
                Proj_M = pinv(H'*H+2*kappa*muInv*eye(n))*H';
            else
                Proj_M = H'*pinv(H*H'+2*kappa*muInv*eye(m));
            end
            
            while ~converged_main
                lambdaScaled = muInv*lambda ;
                nIter  = nIter + 1 ;
                beta   = Proj_M*(Y-e+lambdaScaled);    %-------------(1)
                temp   = Y + lambdaScaled - H*beta;
                e = sign(temp).*max(abs(temp)-muInv,0);%-------------(2)
                lambda = lambda + mu*(Y - H*beta - e); %-------------(3)
                if nIter >= self.maxIter
                    converged_main = 1 ;
                end
            end
            self.outputWeight = beta;
            %--------------------------------------------------------------
            self.trainTime = toc - auxTime;
        end
        function Yhat = predict(self, X)
            auxTime = toc;
            tempH = X*self.inputWeight + repmat(self.biasOfHiddenNeurons,size(X,1),1);
            H = self.activationFunction(tempH);
            clear tempH;
            Yhat = H * self.outputWeight;
            self.lastTestTime = toc - auxTime;
        end
    end
end
