% IFELM - Inverse Free Extreme Learning Machine Class
%   Train and Predict a IFELM based on Inverse Free Extreme Learning Machine
%
%   This code was implemented based on the following paper:
%
%   [1] Shuai Li, Zhu-Hong You, Hongliang Guo, Xin Luo, and Zhong-Qiu Zhao, 
%       Inverse-Free Extreme Learning Machine With Optimal Information Updating, 
%       IEEE Transactions on Cybernetics, vol. 46, no. 5, pp. 1229?1241, 2016.
%       http://dx.doi.org/10.1109/TCYB.2015.2434841
%       (http://ieeexplore.ieee.org/document/7115113/)
%       
%   Attributes:
%       Attributes between *.* must be informed.
%       IFELM objects must be created using name-value pair arguments (see the Usage Example).
%
%         *numberOfInputNeurons*:   Number of neurons in the input layer.
%                Accepted Values:   Any positive integer.
%
%          numberOfHiddenNeurons:   Number of neurons in the hidden layer
%                Accepted Values:   Any positive integer (defaut = 1000).
%
%       regularizationParameter:   Regularization Parameter (defaut = 1000)
%                Accepted Values:   Any positive real number.
%
%                          alpha:   Regularization Parameter (defaut = 0)
%                Accepted Values:   Any positive real number between [0,1].
%                                   0: ridge | 1: lasso | (0,1): elastic net
%
%             activationFunction:   Activation funcion for hidden layer
%                Accepted Values:   Function handle (see [1]) or one of these strings:
%                                       'sig':     Sigmoid (default)
%                                       'sin':     Sine
%                                       'hardlim': Hard Limit
%                                       'tribas':  Triangular basis function
%                                       'radbas':  Radial basis function
%
%                           seed:   Seed to generate the pseudo-random values.
%                                   This attribute is for reproducible research.
%                Accepted Values:   RandStream object or a integer seed for RandStream.
%
%       Attributes generated by the code:
%
%                    inputWeight:   Weight matrix that connects the input
%                                   layer to the hidden layer
%
%            biasOfHiddenNeurons:   Bias of hidden units
%
%                   outputWeight:   Weight matrix that connects the hidden
%                                   layer to the output layer
%
%                      intercept:   Intercept value (beta_0) for alpha in
%                                   (0,1]
%
%                     pMat, hMat:   Matrices used for sequentially updating  
%                                   the outputWeight matrix
%
%   Methods:
%
%       obj = IFELM(varargin):       Creates IFELM objects. varargin should be in
%                                    pairs. Look attributes
%
%       obj = obj.train(X,Y):        Method for training. X is the input of size N x n,
%                                    where N is (# of samples) and n is the (# of features).
%                                    Y is the output of size N x m, where m is (# of multiple outputs)
%
%       Yhat = obj.predict(X):       Predicts the output for X.
%
%   Usage Example:
%
%       load iris_dataset.mat
%       X    = irisInputs';
%       Y    = irisTargets';
%       ifelm  = IFELM('numberOfInputNeurons', 4, 'numberOfHiddenNeurons',100);
%       ifelm  = ifelm.train(X, Y);
%       Yhat = ifelm.predict(X)

%   License:
%
%   Permission to use, copy, or modify this software and its documentation
%   for educational and research purposes only and without fee is here
%   granted, provided that this copyright notice and the original authors'
%   names appear on all copies and supporting documentation. This program
%   shall not be used, rewritten, or adapted as the basis of a commercial
%   software or hardware product without first obtaining permission of the
%   authors. The authors make no representations about the suitability of
%   this software for any purpose. It is provided "as is" without express
%   or implied warranty.
%
%       Federal University of Espirito Santo (UFES), Brazil
%       Computers and Neural Systems Lab. (LabCISNE)
%       Authors:    F. K. Inaba, B. L. S. Silva, D. L. Cosmo
%       email:      labcisne@gmail.com
%       website:    github.com/labcisne/ELMToolbox
%       date:       Feb/2018

classdef IFELM < RELM
    properties                       
        pMat = []
        hMat = []
        addNumberOfNeurons = 1
    end
    methods
        function self = IFELM(varargin)
            self = self@RELM(varargin{:});
        end
        
        function self = train(self, X, Y) 
            auxTime = toc;
            if isempty(self.pMat)
                if ~isempty(self.outputWeight)
                    self.numberOfHiddenNeurons = self.numberOfHiddenNeurons + self.addNumberOfNeurons;
                end
                self = train@RELM(self,X,Y);                
                tempH = X*self.inputWeight + repmat(self.biasOfHiddenNeurons,size(X,1),1);
                self.hMat = self.activationFunction(tempH);
                clear tempH;
                if self.numberOfHiddenNeurons < size(X,1)
                    self.pMat = pinv(self.hMat'*self.hMat + eye(size(self.hMat,2))/self.regularizationParameter);
                else
                    self.pMat = pinv(self.hMat*self.hMat' + eye(size(self.hMat,1))/self.regularizationParameter);
                end
            else
                a = rand(self.seed, self.numberOfInputNeurons,self.addNumberOfNeurons)*2-1;
                b = rand(self.seed, 1, self.addNumberOfNeurons);
                temph = X*a + repmat(b,size(X,1),1);
                h = self.activationFunction(temph);
                clear temph;
                if self.numberOfHiddenNeurons < size(X,1)
                    th = self.pMat*self.hMat'*h;
                    S = pinv((h'*h + eye(size(h,2))/self.regularizationParameter) - h'*self.hMat*th);
                    A = self.pMat + th*S*th';
                    B = -th*S;
                    C = -S*th';
                    self.pMat = [A B;C S];
                    
                    self.hMat = [self.hMat h];
                    
                    self.inputWeight = [self.inputWeight a];
                    self.numberOfHiddenNeurons = self.numberOfHiddenNeurons + self.addNumberOfNeurons;
                    self.biasOfHiddenNeurons = [self.biasOfHiddenNeurons b];
                    
                    self.outputWeight = self.pMat*self.hMat'*Y;
                    if (self.numberOfHiddenNeurons >= size(X,1))
                        self.pMat = [];
                        self.hMat = [];
                    end
                else
                    self.pMat = self.pMat - self.pMat * h  * ((eye(size(h,2)) + h'* self.pMat * h ) \ h') *self.pMat;
                    self.hMat = [self.hMat h];
                    
                    self.inputWeight = [self.inputWeight a];
                    self.numberOfHiddenNeurons = self.numberOfHiddenNeurons + self.addNumberOfNeurons;
                    self.biasOfHiddenNeurons = [self.biasOfHiddenNeurons b];
                    
                    self.outputWeight = self.hMat'*self.pMat*Y;
                end              
            end
            self.trainTime = toc - auxTime;
        end
    end
end
