% KELM - Kernel Extreme Learning Machine Class
%   Train and Predict a SLFN based on Kernel Extreme Learning Machine
%
%   This code was implemented based on the following paper:
%
%   [1] Guang-Bin Huang, Hongming Zhou, Xiaojian Ding, and Rui Zhang, Extreme 
%       Learning Machine for Regression and Multiclass Classification. 
%       Trans. Sys. Man Cyber. Part B 42, 2 (April 2012), 513-529. 
%       http://dx.doi.org/10.1109/TSMCB.2011.2168604 
%       (http://ieeexplore.ieee.org/document/6035797/)
%
%   Attributes: 
%       Attributes between *.* must be informed.
%       K-ELM objects must be created using name-value pairs (see the Usage Example).
%
%                    Kernel_type:   Function that defines kernel  
%                Accepted Values:   one of these strings (function handles will be supported in the future):
%                                       'RBF_kernel':     Radial Basis Function (default)
%                                       'lin_kernel':     Linear
%                                       'poly_kernel':    Polynomial
%                                       'wav_kernel':     Wavelet
%
%                   Kernel_param:   Kernel Parameter 
%                Accepted Values:   Any positive real number (defaut = 0.1).
%
%
%       Regularization_parameter:   Regularization Parameter 
%                Accepted Values:   Any positive real number (defaut = 1000).
%
%       Attributes generated by the code:
%
%                            Xtr:   Training data (defined when the model is trained).
%
%                   OutputWeight:   Weight matrix that connects the hidden
%                                   layer to the output layer
%
%   Methods:
%
%       obj = KELM(varargin):       Creates KELM objects. varargin should be in
%                                   pairs. Look attributes.
%
%       obj = obj.train(X,Y):       Method for training. X is the input of size N x n,
%                                   where N is (# of samples) and n is the (# of features).
%                                   Y is the output of size N x m, where m is (# of multiple outputs)
%                            
%       Yhat = obj.predict(X):      Predicts the output for X.
%
%   Usage Example:
%
%       load iris_dataset.mat
%       X    = irisInputs';
%       Y    = irisTargets';
%       kelm  = KELM();
%       kelm  = kelm.train(X, Y);
%       Yhat = kelm.predict(X)

%   License:
%
%   Permission to use, copy, or modify this software and its documentation
%   for educational and research purposes only and without fee is here
%   granted, provided that this copyright notice and the original authors'
%   names appear on all copies and supporting documentation. This program
%   shall not be used, rewritten, or adapted as the basis of a commercial
%   software or hardware product without first obtaining permission of the
%   authors. The authors make no representations about the suitability of
%   this software for any purpose. It is provided "as is" without express
%   or implied warranty.
%
%       Federal University of Espirito Santo (UFES), Brazil
%       Computers and Neural Systems Lab. (LabCISNE)
%       Authors:    F. K. Inaba, B. L. S. Silva, D. L. Cosmo 
%       email:      labcisne@gmail.com
%       website:    github.com/labcisne/ELMToolbox
%       date:       Jan/2018

classdef KELM
    properties
        Kernel_type = 'RBF_kernel'
        Kernel_param = 0.1
        Regularization_parameter = 1000
        OutputWeight = []        
        Xtr = []
    end
    methods
        function obj = KELM(varargin)
            for i = 1:2:nargin
                obj.(varargin{i}) = varargin{i+1};
            end
        end
        
        function omega = kernel_matrix(self,Xte)            
            nb_data = size(self.Xtr,1);
            if strcmp(self.Kernel_type,'RBF_kernel')
                if nargin<2
                    XXh = sum(self.Xtr.^2,2)*ones(1,nb_data);
                    omega = XXh + XXh' - 2*(self.Xtr*self.Xtr');
                    omega = exp(-omega./self.Kernel_param(1));
                else
                    XXh1 = sum(self.Xtr.^2,2)*ones(1,size(Xte,1));
                    XXh2 = sum(Xte.^2,2)*ones(1,nb_data);
                    omega = XXh1 + XXh2' - 2*self.Xtr*Xte';
                    omega = exp(-omega./self.Kernel_param(1));
                end
                
            elseif strcmp(self.Kernel_type,'lin_kernel')
                if nargin<2
                    omega = self.Xtr*self.Xtr';
                else
                    omega = self.Xtr*Xte';
                end
                
            elseif strcmp(self.Kernel_type,'poly_kernel')
                if nargin<4
                    omega = (self.Xtr*self.Xtr' + self.Kernel_param(1)).^self.Kernel_param(2);
                else
                    omega = (self.Xtr*Xte' + self.Kernel_param(1)).^self.Kernel_param(2);
                end
                
            elseif strcmp(self.Kernel_type,'wav_kernel')
                if nargin<2
                    XXh = sum(self.Xtr.^2,2)*ones(1,nb_data);
                    omega = XXh+XXh' - 2*(self.Xtr*self.Xtr');
                    
                    XXh1 = sum(self.Xtr,2)*ones(1,nb_data);
                    omega1 = XXh1 - XXh1';
                    omega = cos(self.Kernel_param(3)*omega1./self.Kernel_param(2)).*exp(-omega./self.Kernel_param(1));
                    
                else
                    XXh1 = sum(self.Xtr.^2,2)*ones(1,size(Xte,1));
                    XXh2 = sum(Xte.^2,2)*ones(1,nb_data);
                    omega = XXh1+XXh2' - 2*(self.Xtr*Xte');
                    
                    XXh11 = sum(self.Xtr,2)*ones(1,size(Xte,1));
                    XXh22 = sum(Xte,2)*ones(1,nb_data);
                    omega1 = XXh11 - XXh22';
                    
                    omega = cos(self.Kernel_param(3)*omega1./self.Kernel_param(2)).*exp(-omega./self.Kernel_param(1));
                end
            end
        end
        
        function self = train(self, X, Y)
            self.Xtr = X;
            Omega_train = kernel_matrix(self);
            self.OutputWeight=((Omega_train + speye(size(Y,1))/self.Regularization_parameter)\(Y));
        end
        function Yhat = predict(self, Xte)
            Omega_test = kernel_matrix(self, Xte);
            Yhat = Omega_test' * self.OutputWeight;
        end
    end
end